<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nlib2: nlib2::Modflow Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nlib2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>nlib2</b></li><li class="navelem"><a class="el" href="classnlib2_1_1Modflow.html">Modflow</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classnlib2_1_1Modflow-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nlib2::Modflow Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__modflow.html">Modflow: a graph based modular interface</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the main class that handles the call flow between modules. First, you will need to derive this class and override <a class="el" href="classnlib2_1_1Modflow.html#ad48414425831bab7fa9ec617cd1a0aa2">loadModules</a>, calling <a class="el" href="classnlib2_1_1Modflow.html#a7454ed4e6961c6db8d5adf2128250b73">loadModule</a> with the type of each module you want to load as template parameter. Then:  
 <a href="classnlib2_1_1Modflow.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="nl__modflow_8h_source.html">nl_modflow.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for nlib2::Modflow:</div>
<div class="dyncontent">
<div class="center"><img src="classnlib2_1_1Modflow__inherit__graph.png" border="0" usemap="#anlib2_1_1Modflow_inherit__map" alt="Inheritance graph"/></div>
<map name="anlib2_1_1Modflow_inherit__map" id="anlib2_1_1Modflow_inherit__map">
<area shape="rect" title="This is the main class that handles the call flow between modules. First, you will need to derive thi..." alt="" coords="35,95,152,121"/>
<area shape="rect" title=" " alt="" coords="5,5,181,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for nlib2::Modflow:</div>
<div class="dyncontent">
<div class="center"><img src="classnlib2_1_1Modflow__coll__graph.png" border="0" usemap="#anlib2_1_1Modflow_coll__map" alt="Collaboration graph"/></div>
<map name="anlib2_1_1Modflow_coll__map" id="anlib2_1_1Modflow_coll__map">
<area shape="rect" title="This is the main class that handles the call flow between modules. First, you will need to derive thi..." alt="" coords="135,109,252,136"/>
<area shape="rect" title=" " alt="" coords="5,5,181,47"/>
<area shape="rect" href="classnlib2_1_1ResourceManager.html" title="Allow sharing resources of generic types among modules." alt="" coords="205,13,384,39"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a33bfdad4e257e8e189b5f06aeeeb0a3e"><td class="memItemLeft" align="right" valign="top"><a id="a33bfdad4e257e8e189b5f06aeeeb0a3e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlib2_1_1Modflow.html#a33bfdad4e257e8e189b5f06aeeeb0a3e">init</a> (const NlParams::SharedPtr &amp;nlParams=nullptr)</td></tr>
<tr class="memdesc:a33bfdad4e257e8e189b5f06aeeeb0a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the first function to be called. It loads sources and sink modules. After that, it calls the virtual function <a class="el" href="classnlib2_1_1Modflow.html#ad48414425831bab7fa9ec617cd1a0aa2">loadModules</a>, that each <a class="el" href="classnlib2_1_1Module.html" title="This is the core node of a Modflow graph. Inherit this class to define the main computation units to ...">Module</a> derived class must override, that is supposed to load all the modules, in the provided order. <code>nlParams</code> is the overall parameter server. If initialized with nullptr all parameter-related methods call will be disabled. <br /></td></tr>
<tr class="separator:a33bfdad4e257e8e189b5f06aeeeb0a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb940191b88b5127e2e48ea1ed1033e"><td class="memItemLeft" align="right" valign="top"><a id="a6fb940191b88b5127e2e48ea1ed1033e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlib2_1_1Modflow.html#a6fb940191b88b5127e2e48ea1ed1033e">finalize</a> ()</td></tr>
<tr class="memdesc:a6fb940191b88b5127e2e48ea1ed1033e"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be called after the declaration of sources and sinks. For each module in the same order as specified in setupNetwork, it calls <a class="el" href="classnlib2_1_1Module.html#a7f2cb22a956bb745353461378e3e83e4">Module::initParams</a> (if a <a class="el" href="classnlib2_1_1NlParams.html">NlParams</a> parameter server has been supplied) and then <a class="el" href="classnlib2_1_1Module.html#acccd99465fa5b7b7add56006eecbab9d">Module::setupNetwork</a>. <br /></td></tr>
<tr class="separator:a6fb940191b88b5127e2e48ea1ed1033e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cc3a2e1c7bc9bd974a2f5555e5bcf4"><td class="memItemLeft" align="right" valign="top"><a id="ac6cc3a2e1c7bc9bd974a2f5555e5bcf4"></a>
Sources::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlib2_1_1Modflow.html#ac6cc3a2e1c7bc9bd974a2f5555e5bcf4">sources</a> ()</td></tr>
<tr class="memdesc:ac6cc3a2e1c7bc9bd974a2f5555e5bcf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the source module object. <br /></td></tr>
<tr class="separator:ac6cc3a2e1c7bc9bd974a2f5555e5bcf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589652cdb4088949c2765e792be1dfc7"><td class="memItemLeft" align="right" valign="top"><a id="a589652cdb4088949c2765e792be1dfc7"></a>
Sinks::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlib2_1_1Modflow.html#a589652cdb4088949c2765e792be1dfc7">sinks</a> ()</td></tr>
<tr class="memdesc:a589652cdb4088949c2765e792be1dfc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the sinks module object. <br /></td></tr>
<tr class="separator:a589652cdb4088949c2765e792be1dfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1367a8a38fac6e9b1b8dbc117fb1435c"><td class="memItemLeft" align="right" valign="top"><a id="a1367a8a38fac6e9b1b8dbc117fb1435c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlib2_1_1Modflow.html#a1367a8a38fac6e9b1b8dbc117fb1435c">onParameterChange</a> (const std::string &amp;fullPath, const NlParams::SharedPtr &amp;nlParams)</td></tr>
<tr class="memdesc:a1367a8a38fac6e9b1b8dbc117fb1435c"><td class="mdescLeft">&#160;</td><td class="mdescRight">From the full parameter path, it extracts, the module name, finds the module in the module list, and calls Module::onParameterChange with the rest of the parameter path. <br /></td></tr>
<tr class="separator:a1367a8a38fac6e9b1b8dbc117fb1435c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa341f52ea9ad129cd45a0154f77dc65e"><td class="memTemplParams" colspan="2"><a id="aa341f52ea9ad129cd45a0154f77dc65e"></a>
template&lt;class DerivedModflow &gt; </td></tr>
<tr class="memitem:aa341f52ea9ad129cd45a0154f77dc65e"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classnlib2_1_1Modflow.html">Modflow</a>, DerivedModflow &gt;, Modflow::SharedPtr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlib2_1_1Modflow.html#aa341f52ea9ad129cd45a0154f77dc65e">create</a> ()</td></tr>
<tr class="memdesc:aa341f52ea9ad129cd45a0154f77dc65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classnlib2_1_1Modflow.html" title="This is the main class that handles the call flow between modules. First, you will need to derive thi...">Modflow</a> object must be created via this method, which creates a shared pointer, instantiated with the derived class type supplied as template parameter. <br /></td></tr>
<tr class="separator:aa341f52ea9ad129cd45a0154f77dc65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7454ed4e6961c6db8d5adf2128250b73"><td class="memTemplParams" colspan="2">template&lt;class DerivedModule , typename ... Args&gt; </td></tr>
<tr class="memitem:a7454ed4e6961c6db8d5adf2128250b73"><td class="memTemplItemLeft" align="right" valign="top">DerivedModule::SharedPtr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlib2_1_1Modflow.html#a7454ed4e6961c6db8d5adf2128250b73">loadModule</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a7454ed4e6961c6db8d5adf2128250b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a dynamically allocated object of type <code>DerivedModule</code>, as shared pointer, and stores into <a class="el" href="classnlib2_1_1Modflow.html" title="This is the main class that handles the call flow between modules. First, you will need to derive thi...">Modflow</a>'s modules list.  <a href="classnlib2_1_1Modflow.html#a7454ed4e6961c6db8d5adf2128250b73">More...</a><br /></td></tr>
<tr class="separator:a7454ed4e6961c6db8d5adf2128250b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48414425831bab7fa9ec617cd1a0aa2"><td class="memItemLeft" align="right" valign="top"><a id="ad48414425831bab7fa9ec617cd1a0aa2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlib2_1_1Modflow.html#ad48414425831bab7fa9ec617cd1a0aa2">loadModules</a> ()=0</td></tr>
<tr class="memdesc:ad48414425831bab7fa9ec617cd1a0aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to be overridden to specify the modules to be loaded via <a class="el" href="classnlib2_1_1Modflow.html#a7454ed4e6961c6db8d5adf2128250b73">loadModule</a>. <br /></td></tr>
<tr class="separator:ad48414425831bab7fa9ec617cd1a0aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add865d3950356993cea2d69c790293ca"><td class="memTemplParams" colspan="2">template&lt;typename ... ChannelTs&gt; </td></tr>
<tr class="memitem:add865d3950356993cea2d69c790293ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classnlib2_1_1Channel.html">Channel</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlib2_1_1Modflow.html#add865d3950356993cea2d69c790293ca">createChannel</a> (const std::string &amp;name, const <a class="el" href="classnlib2_1_1Module.html">Module</a> *owner, bool isSink=false)</td></tr>
<tr class="memdesc:add865d3950356993cea2d69c790293ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a new channel of types <code></code>...ChannelTs. The channel is owned by module <code>owner</code>, that is the only module that can emit events on this channel.  <a href="classnlib2_1_1Modflow.html#add865d3950356993cea2d69c790293ca">More...</a><br /></td></tr>
<tr class="separator:add865d3950356993cea2d69c790293ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a04230250ef2707a601efe38be834d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classnlib2_1_1Channel.html">Channel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnlib2_1_1Modflow.html#a8a04230250ef2707a601efe38be834d7">resolveChannel</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a8a04230250ef2707a601efe38be834d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classnlib2_1_1Channel.html">Channel</a> object given its name.  <a href="classnlib2_1_1Modflow.html#a8a04230250ef2707a601efe38be834d7">More...</a><br /></td></tr>
<tr class="separator:a8a04230250ef2707a601efe38be834d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdf38dcbcf1db61f8d1ace93064c7db"><td class="memTemplParams" colspan="2">template&lt;typename ReturnT , typename ... ChannelTs&gt; </td></tr>
<tr class="memitem:afcdf38dcbcf1db61f8d1ace93064c7db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlib2_1_1Modflow.html#afcdf38dcbcf1db61f8d1ace93064c7db">createConnection</a> (const <a class="el" href="classnlib2_1_1Channel.html">Channel</a> &amp;channel, const Slot&lt; ReturnT, ChannelTs... &gt; &amp;slot, const std::string &amp;name)</td></tr>
<tr class="memdesc:afcdf38dcbcf1db61f8d1ace93064c7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a connection named <code>name</code> from <code>channel</code> to a <code>slot</code> function.  <a href="classnlib2_1_1Modflow.html#afcdf38dcbcf1db61f8d1ace93064c7db">More...</a><br /></td></tr>
<tr class="separator:afcdf38dcbcf1db61f8d1ace93064c7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937c5c08735a23fa5fcf92178f960fe2"><td class="memTemplParams" colspan="2">template&lt;typename ReturnT , typename ... ChannelTs&gt; </td></tr>
<tr class="memitem:a937c5c08735a23fa5fcf92178f960fe2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; ReturnT, void &gt;, ReturnT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnlib2_1_1Modflow.html#a937c5c08735a23fa5fcf92178f960fe2">emit</a> (const <a class="el" href="classnlib2_1_1Channel.html">Channel</a> &amp;channel, const <a class="el" href="classnlib2_1_1Module.html">Module</a> *caller, ChannelTs &amp;&amp;...args)</td></tr>
<tr class="memdesc:a937c5c08735a23fa5fcf92178f960fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a signal on <code>channel</code>. This will call the slot methods associated to the channel of each module, supplying <code></code>...args.  <a href="classnlib2_1_1Modflow.html#a937c5c08735a23fa5fcf92178f960fe2">More...</a><br /></td></tr>
<tr class="separator:a937c5c08735a23fa5fcf92178f960fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6dc9325f4761c0df88a79e48aa7daeb"><td class="memTemplParams" colspan="2"><a id="ae6dc9325f4761c0df88a79e48aa7daeb"></a>
template&lt;typename ReturnT , typename ... ChannelTs&gt; </td></tr>
<tr class="memitem:ae6dc9325f4761c0df88a79e48aa7daeb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_same_v&lt; ReturnT, void &gt;, ReturnT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emit</b> (const <a class="el" href="classnlib2_1_1Channel.html">Channel</a> &amp;channel, const <a class="el" href="classnlib2_1_1Module.html">Module</a> *caller, ChannelTs &amp;&amp;...args)</td></tr>
<tr class="separator:ae6dc9325f4761c0df88a79e48aa7daeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1abcf7f8422e1edcbf05c2a2d31848"><td class="memTemplParams" colspan="2"><a id="a5e1abcf7f8422e1edcbf05c2a2d31848"></a>
template&lt;typename ReturnT , typename ... ChannelTs&gt; </td></tr>
<tr class="memitem:a5e1abcf7f8422e1edcbf05c2a2d31848"><td class="memTemplItemLeft" align="right" valign="top">ReturnT&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emit</b> (const std::string &amp;channelname, const <a class="el" href="classnlib2_1_1Module.html">Module</a> *caller, ChannelTs &amp;&amp;...args)</td></tr>
<tr class="separator:a5e1abcf7f8422e1edcbf05c2a2d31848"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:afe49f41dc8faf79cff708937079ab9f0"><td class="memItemLeft" align="right" valign="top"><a id="afe49f41dc8faf79cff708937079ab9f0"></a>
NlParams::SharedPtr&#160;</td><td class="memItemRight" valign="bottom"><b>_nlParams</b></td></tr>
<tr class="separator:afe49f41dc8faf79cff708937079ab9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57d1eed823a93b0c0e6c806b1c00973"><td class="memItemLeft" align="right" valign="top"><a id="ab57d1eed823a93b0c0e6c806b1c00973"></a>
<a class="el" href="classnlib2_1_1ResourceManager.html">ResourceManager</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_resources</b></td></tr>
<tr class="separator:ab57d1eed823a93b0c0e6c806b1c00973"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a21f639900c480510650969df9c74d17d"><td class="memItemLeft" align="right" valign="top"><a id="a21f639900c480510650969df9c74d17d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Module</b></td></tr>
<tr class="separator:a21f639900c480510650969df9c74d17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edf834afae5730ad2d5c690f7cf2b46"><td class="memItemLeft" align="right" valign="top"><a id="a1edf834afae5730ad2d5c690f7cf2b46"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Sources</b></td></tr>
<tr class="separator:a1edf834afae5730ad2d5c690f7cf2b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5950ab671e5b4034cc8c65e925cb43bb"><td class="memItemLeft" align="right" valign="top"><a id="a5950ab671e5b4034cc8c65e925cb43bb"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Sinks</b></td></tr>
<tr class="separator:a5950ab671e5b4034cc8c65e925cb43bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the main class that handles the call flow between modules. First, you will need to derive this class and override <a class="el" href="classnlib2_1_1Modflow.html#ad48414425831bab7fa9ec617cd1a0aa2">loadModules</a>, calling <a class="el" href="classnlib2_1_1Modflow.html#a7454ed4e6961c6db8d5adf2128250b73">loadModule</a> with the type of each module you want to load as template parameter. Then: </p>
<ul>
<li>Create Modflow::SharedPtr with <a class="el" href="classnlib2_1_1Modflow.html#aa341f52ea9ad129cd45a0154f77dc65e" title="A Modflow object must be created via this method, which creates a shared pointer, instantiated with t...">Modflow::create</a>, with your <a class="el" href="classnlib2_1_1Modflow.html" title="This is the main class that handles the call flow between modules. First, you will need to derive thi...">Modflow</a> derived class template</li>
<li>Initialize the modflow object with <a class="el" href="classnlib2_1_1Modflow.html#a33bfdad4e257e8e189b5f06aeeeb0a3e">init</a>, which will initialize sources and sinks modules</li>
<li>Declare source channels via <a class="el" href="classnlib2_1_1Modflow.html#ac6cc3a2e1c7bc9bd974a2f5555e5bcf4">sources()</a> -&gt; <a class="el" href="classnlib2_1_1Sources.html#af4098fcc282ec4543de79c6c0484f86b">Sources::declareSourceChannel</a>, to create entry point channels</li>
<li>Declare sink channels via <a class="el" href="classnlib2_1_1Modflow.html#a589652cdb4088949c2765e792be1dfc7">sinks()</a> -&gt; <a class="el" href="classnlib2_1_1Sinks.html#a03520b4274f119870dc971dbdd26256b">Sinks::declareSink</a>, to connect exit points to external callbacks</li>
<li>Finalize the <a class="el" href="classnlib2_1_1Modflow.html" title="This is the main class that handles the call flow between modules. First, you will need to derive thi...">Modflow</a> initialization via <a class="el" href="classnlib2_1_1Modflow.html#a6fb940191b88b5127e2e48ea1ed1033e">finalize</a> (), which will configure each module by colling <a class="el" href="classnlib2_1_1Module.html#a7f2cb22a956bb745353461378e3e83e4">Module::initParams</a> and <a class="el" href="classnlib2_1_1Module.html#acccd99465fa5b7b7add56006eecbab9d">Module::setupNetwork</a>, that each module shall override. The initialization of the modules is done in the same order they have been loaded.</li>
</ul>
<p>After initialization, sources can be triggered by calling <a class="el" href="classnlib2_1_1Modflow.html#ac6cc3a2e1c7bc9bd974a2f5555e5bcf4">sources()</a> -&gt; <a class="el" href="classnlib2_1_1Sources.html#a45c2bc6b9ae6006ad4e264f2b7dedff0">Sources::callSource</a>, which will emit signals on regular channels as defined by Sources::declareSourceChannels. Modules connected to such channels will receive a function call on its associated slot, which can in turn emit other signals on other channels, which can then be connected to other modules or to sinks. Differently from regular channels, sink channels are connected to an external callback that acts as exit point of <a class="el" href="classnlib2_1_1Modflow.html" title="This is the main class that handles the call flow between modules. First, you will need to derive thi...">Modflow</a>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="add865d3950356993cea2d69c790293ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add865d3950356993cea2d69c790293ca">&#9670;&nbsp;</a></span>createChannel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... ChannelTs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlib2_1_1Channel.html">Channel</a> nlib2::Modflow::createChannel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnlib2_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isSink</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Declare a new channel of types <code></code>...ChannelTs. The channel is owned by module <code>owner</code>, that is the only module that can emit events on this channel. </p>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classnlib2_1_1Channel.html">Channel</a> object with the created channel information </dd></dl>

</div>
</div>
<a id="afcdf38dcbcf1db61f8d1ace93064c7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcdf38dcbcf1db61f8d1ace93064c7db">&#9670;&nbsp;</a></span>createConnection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnT , typename ... ChannelTs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nlib2::Modflow::createConnection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlib2_1_1Channel.html">Channel</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Slot&lt; ReturnT, ChannelTs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a connection named <code>name</code> from <code>channel</code> to a <code>slot</code> function. </p>
<dl class="section note"><dt>Note</dt><dd>Do not call this method directly. Use <a class="el" href="classnlib2_1_1Module.html#ac11760280acec17fa03dbf40c4e1e215" title="Bind signals emitted on a given channel name to a member function slot of the derived module The chan...">Module::requestConnection</a> or <a class="el" href="classnlib2_1_1Sinks.html#a03520b4274f119870dc971dbdd26256b" title="Create a special channel marked as &quot;sink&quot;, and connect signals emitted on such channel to parentCallb...">Sinks::declareSink</a> </dd></dl>

</div>
</div>
<a id="a937c5c08735a23fa5fcf92178f960fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937c5c08735a23fa5fcf92178f960fe2">&#9670;&nbsp;</a></span>emit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnT , typename ... ChannelTs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; ReturnT, void &gt;, ReturnT &gt; nlib2::Modflow::emit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classnlib2_1_1Channel.html">Channel</a> &amp;&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classnlib2_1_1Module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>caller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ChannelTs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit a signal on <code>channel</code>. This will call the slot methods associated to the channel of each module, supplying <code></code>...args. </p>
<dl class="section return"><dt>Returns</dt><dd>If ReturnT is not void, forwards the return value of <code>slot</code>. In this case only one slot can be connected per channel </dd></dl>

</div>
</div>
<a id="a7454ed4e6961c6db8d5adf2128250b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7454ed4e6961c6db8d5adf2128250b73">&#9670;&nbsp;</a></span>loadModule()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DerivedModule , typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DerivedModule::SharedPtr nlib2::Modflow::loadModule </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a dynamically allocated object of type <code>DerivedModule</code>, as shared pointer, and stores into <a class="el" href="classnlib2_1_1Modflow.html" title="This is the main class that handles the call flow between modules. First, you will need to derive thi...">Modflow</a>'s modules list. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to created module </dd></dl>

</div>
</div>
<a id="a8a04230250ef2707a601efe38be834d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a04230250ef2707a601efe38be834d7">&#9670;&nbsp;</a></span>resolveChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classnlib2_1_1Channel.html">Channel</a> nlib2::Modflow::resolveChannel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a <a class="el" href="classnlib2_1_1Channel.html">Channel</a> object given its name. </p>
<dl class="section user"><dt>Complexity Logarithmic in the number of channels</dt><dd></dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/nlib2/<a class="el" href="nl__modflow_8h_source.html">nl_modflow.h</a></li>
<li>include/nlib2/<a class="el" href="nl__modflow__impl_8hpp_source.html">nl_modflow_impl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
