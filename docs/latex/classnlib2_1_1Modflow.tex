\hypertarget{classnlib2_1_1Modflow}{}\doxysection{nlib2\+::Modflow Class Reference}
\label{classnlib2_1_1Modflow}\index{nlib2::Modflow@{nlib2::Modflow}}


This is the main class that handles the call flow between modules. First, you will need to derive this class and override \mbox{\hyperlink{classnlib2_1_1Modflow_ad48414425831bab7fa9ec617cd1a0aa2}{load\+Modules}}, calling \mbox{\hyperlink{classnlib2_1_1Modflow_a7454ed4e6961c6db8d5adf2128250b73}{load\+Module}} with the type of each module you want to load as template parameter. Then\+:  




{\ttfamily \#include $<$nl\+\_\+modflow.\+h$>$}



Inheritance diagram for nlib2\+::Modflow\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=212pt]{classnlib2_1_1Modflow__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for nlib2\+::Modflow\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classnlib2_1_1Modflow__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classnlib2_1_1Modflow_a33bfdad4e257e8e189b5f06aeeeb0a3e}\label{classnlib2_1_1Modflow_a33bfdad4e257e8e189b5f06aeeeb0a3e}} 
void \mbox{\hyperlink{classnlib2_1_1Modflow_a33bfdad4e257e8e189b5f06aeeeb0a3e}{init}} (const Nl\+Params\+::\+Shared\+Ptr \&nl\+Params=nullptr)
\begin{DoxyCompactList}\small\item\em This is the first function to be called. It loads sources and sink modules. After that, it calls the virtual function \mbox{\hyperlink{classnlib2_1_1Modflow_ad48414425831bab7fa9ec617cd1a0aa2}{load\+Modules}}, that each \mbox{\hyperlink{classnlib2_1_1Module}{Module}} derived class must override, that is supposed to load all the modules, in the provided order. {\ttfamily nl\+Params} is the overall parameter server. If initialized with nullptr all parameter-\/related methods call will be disabled. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlib2_1_1Modflow_a6fb940191b88b5127e2e48ea1ed1033e}\label{classnlib2_1_1Modflow_a6fb940191b88b5127e2e48ea1ed1033e}} 
void \mbox{\hyperlink{classnlib2_1_1Modflow_a6fb940191b88b5127e2e48ea1ed1033e}{finalize}} ()
\begin{DoxyCompactList}\small\item\em To be called after the declaration of sources and sinks. For each module in the same order as specified in setup\+Network, it calls \mbox{\hyperlink{classnlib2_1_1Module_a7f2cb22a956bb745353461378e3e83e4}{Module\+::init\+Params}} (if a \mbox{\hyperlink{classnlib2_1_1NlParams}{Nl\+Params}} parameter server has been supplied) and then \mbox{\hyperlink{classnlib2_1_1Module_acccd99465fa5b7b7add56006eecbab9d}{Module\+::setup\+Network}}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlib2_1_1Modflow_ac6cc3a2e1c7bc9bd974a2f5555e5bcf4}\label{classnlib2_1_1Modflow_ac6cc3a2e1c7bc9bd974a2f5555e5bcf4}} 
Sources\+::\+Shared\+Ptr \mbox{\hyperlink{classnlib2_1_1Modflow_ac6cc3a2e1c7bc9bd974a2f5555e5bcf4}{sources}} ()
\begin{DoxyCompactList}\small\item\em Get a pointer to the source module object. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlib2_1_1Modflow_a589652cdb4088949c2765e792be1dfc7}\label{classnlib2_1_1Modflow_a589652cdb4088949c2765e792be1dfc7}} 
Sinks\+::\+Shared\+Ptr \mbox{\hyperlink{classnlib2_1_1Modflow_a589652cdb4088949c2765e792be1dfc7}{sinks}} ()
\begin{DoxyCompactList}\small\item\em Get a pointer to the sinks module object. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlib2_1_1Modflow_a1367a8a38fac6e9b1b8dbc117fb1435c}\label{classnlib2_1_1Modflow_a1367a8a38fac6e9b1b8dbc117fb1435c}} 
void \mbox{\hyperlink{classnlib2_1_1Modflow_a1367a8a38fac6e9b1b8dbc117fb1435c}{on\+Parameter\+Change}} (const std\+::string \&full\+Path, const Nl\+Params\+::\+Shared\+Ptr \&nl\+Params)
\begin{DoxyCompactList}\small\item\em From the full parameter path, it extracts, the module name, finds the module in the module list, and calls Module\+::on\+Parameter\+Change with the rest of the parameter path. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classnlib2_1_1Modflow_aa341f52ea9ad129cd45a0154f77dc65e}\label{classnlib2_1_1Modflow_aa341f52ea9ad129cd45a0154f77dc65e}} 
{\footnotesize template$<$class Derived\+Modflow $>$ }\\static std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+base\+\_\+of\+\_\+v$<$ \mbox{\hyperlink{classnlib2_1_1Modflow}{Modflow}}, Derived\+Modflow $>$, Modflow\+::\+Shared\+Ptr $>$ \mbox{\hyperlink{classnlib2_1_1Modflow_aa341f52ea9ad129cd45a0154f77dc65e}{create}} ()
\begin{DoxyCompactList}\small\item\em A \mbox{\hyperlink{classnlib2_1_1Modflow}{Modflow}} object must be created via this method, which creates a shared pointer, instantiated with the derived class type supplied as template parameter. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class Derived\+Module , typename ... Args$>$ }\\Derived\+Module\+::\+Shared\+Ptr \mbox{\hyperlink{classnlib2_1_1Modflow_a7454ed4e6961c6db8d5adf2128250b73}{load\+Module}} (Args \&\&...args)
\begin{DoxyCompactList}\small\item\em Construct a dynamically allocated object of type {\ttfamily Derived\+Module}, as shared pointer, and stores into \mbox{\hyperlink{classnlib2_1_1Modflow}{Modflow}}\textquotesingle{}s modules list. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlib2_1_1Modflow_ad48414425831bab7fa9ec617cd1a0aa2}\label{classnlib2_1_1Modflow_ad48414425831bab7fa9ec617cd1a0aa2}} 
virtual void \mbox{\hyperlink{classnlib2_1_1Modflow_ad48414425831bab7fa9ec617cd1a0aa2}{load\+Modules}} ()=0
\begin{DoxyCompactList}\small\item\em Method to be overridden to specify the modules to be loaded via \mbox{\hyperlink{classnlib2_1_1Modflow_a7454ed4e6961c6db8d5adf2128250b73}{load\+Module}}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename ... Channel\+Ts$>$ }\\\mbox{\hyperlink{classnlib2_1_1Channel}{Channel}} \mbox{\hyperlink{classnlib2_1_1Modflow_add865d3950356993cea2d69c790293ca}{create\+Channel}} (const std\+::string \&name, const \mbox{\hyperlink{classnlib2_1_1Module}{Module}} $\ast$owner, bool is\+Sink=false)
\begin{DoxyCompactList}\small\item\em Declare a new channel of types {\ttfamily }...Channel\+Ts. The channel is owned by module {\ttfamily owner}, that is the only module that can emit events on this channel. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classnlib2_1_1Channel}{Channel}} \mbox{\hyperlink{classnlib2_1_1Modflow_a8a04230250ef2707a601efe38be834d7}{resolve\+Channel}} (const std\+::string \&name)
\begin{DoxyCompactList}\small\item\em Get a \mbox{\hyperlink{classnlib2_1_1Channel}{Channel}} object given its name. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename ReturnT , typename ... Channel\+Ts$>$ }\\void \mbox{\hyperlink{classnlib2_1_1Modflow_afcdf38dcbcf1db61f8d1ace93064c7db}{create\+Connection}} (const \mbox{\hyperlink{classnlib2_1_1Channel}{Channel}} \&channel, const Slot$<$ ReturnT, Channel\+Ts... $>$ \&slot, const std\+::string \&name)
\begin{DoxyCompactList}\small\item\em Create a connection named {\ttfamily name} from {\ttfamily channel} to a {\ttfamily slot} function. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename ReturnT , typename ... Channel\+Ts$>$ }\\std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+same\+\_\+v$<$ ReturnT, void $>$, ReturnT $>$ \mbox{\hyperlink{classnlib2_1_1Modflow_a937c5c08735a23fa5fcf92178f960fe2}{emit}} (const \mbox{\hyperlink{classnlib2_1_1Channel}{Channel}} \&channel, const \mbox{\hyperlink{classnlib2_1_1Module}{Module}} $\ast$caller, Channel\+Ts \&\&...args)
\begin{DoxyCompactList}\small\item\em Emit a signal on {\ttfamily channel}. This will call the slot methods associated to the channel of each module, supplying {\ttfamily }...args. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlib2_1_1Modflow_ae6dc9325f4761c0df88a79e48aa7daeb}\label{classnlib2_1_1Modflow_ae6dc9325f4761c0df88a79e48aa7daeb}} 
{\footnotesize template$<$typename ReturnT , typename ... Channel\+Ts$>$ }\\std\+::enable\+\_\+if\+\_\+t$<$!std\+::is\+\_\+same\+\_\+v$<$ ReturnT, void $>$, ReturnT $>$ {\bfseries emit} (const \mbox{\hyperlink{classnlib2_1_1Channel}{Channel}} \&channel, const \mbox{\hyperlink{classnlib2_1_1Module}{Module}} $\ast$caller, Channel\+Ts \&\&...args)
\item 
\mbox{\Hypertarget{classnlib2_1_1Modflow_a5e1abcf7f8422e1edcbf05c2a2d31848}\label{classnlib2_1_1Modflow_a5e1abcf7f8422e1edcbf05c2a2d31848}} 
{\footnotesize template$<$typename ReturnT , typename ... Channel\+Ts$>$ }\\ReturnT {\bfseries emit} (const std\+::string \&channelname, const \mbox{\hyperlink{classnlib2_1_1Module}{Module}} $\ast$caller, Channel\+Ts \&\&...args)
\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classnlib2_1_1Modflow_afe49f41dc8faf79cff708937079ab9f0}\label{classnlib2_1_1Modflow_afe49f41dc8faf79cff708937079ab9f0}} 
Nl\+Params\+::\+Shared\+Ptr {\bfseries \+\_\+nl\+Params}
\item 
\mbox{\Hypertarget{classnlib2_1_1Modflow_ab57d1eed823a93b0c0e6c806b1c00973}\label{classnlib2_1_1Modflow_ab57d1eed823a93b0c0e6c806b1c00973}} 
\mbox{\hyperlink{classnlib2_1_1ResourceManager}{Resource\+Manager}} {\bfseries \+\_\+resources}
\end{DoxyCompactItemize}
\doxysubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classnlib2_1_1Modflow_a21f639900c480510650969df9c74d17d}\label{classnlib2_1_1Modflow_a21f639900c480510650969df9c74d17d}} 
class {\bfseries Module}
\item 
\mbox{\Hypertarget{classnlib2_1_1Modflow_a1edf834afae5730ad2d5c690f7cf2b46}\label{classnlib2_1_1Modflow_a1edf834afae5730ad2d5c690f7cf2b46}} 
class {\bfseries Sources}
\item 
\mbox{\Hypertarget{classnlib2_1_1Modflow_a5950ab671e5b4034cc8c65e925cb43bb}\label{classnlib2_1_1Modflow_a5950ab671e5b4034cc8c65e925cb43bb}} 
class {\bfseries Sinks}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
This is the main class that handles the call flow between modules. First, you will need to derive this class and override \mbox{\hyperlink{classnlib2_1_1Modflow_ad48414425831bab7fa9ec617cd1a0aa2}{load\+Modules}}, calling \mbox{\hyperlink{classnlib2_1_1Modflow_a7454ed4e6961c6db8d5adf2128250b73}{load\+Module}} with the type of each module you want to load as template parameter. Then\+: 


\begin{DoxyItemize}
\item Create Modflow\+::\+Shared\+Ptr with \mbox{\hyperlink{classnlib2_1_1Modflow_aa341f52ea9ad129cd45a0154f77dc65e}{Modflow\+::create}}, with your \mbox{\hyperlink{classnlib2_1_1Modflow}{Modflow}} derived class template
\item Initialize the modflow object with \mbox{\hyperlink{classnlib2_1_1Modflow_a33bfdad4e257e8e189b5f06aeeeb0a3e}{init}}, which will initialize sources and sinks modules
\item Declare source channels via \mbox{\hyperlink{classnlib2_1_1Modflow_ac6cc3a2e1c7bc9bd974a2f5555e5bcf4}{sources()}} -\/$>$ \mbox{\hyperlink{classnlib2_1_1Sources_af4098fcc282ec4543de79c6c0484f86b}{Sources\+::declare\+Source\+Channel}}, to create entry point channels
\item Declare sink channels via \mbox{\hyperlink{classnlib2_1_1Modflow_a589652cdb4088949c2765e792be1dfc7}{sinks()}} -\/$>$ \mbox{\hyperlink{classnlib2_1_1Sinks_a03520b4274f119870dc971dbdd26256b}{Sinks\+::declare\+Sink}}, to connect exit points to external callbacks
\item Finalize the \mbox{\hyperlink{classnlib2_1_1Modflow}{Modflow}} initialization via \mbox{\hyperlink{classnlib2_1_1Modflow_a6fb940191b88b5127e2e48ea1ed1033e}{finalize}} (), which will configure each module by colling \mbox{\hyperlink{classnlib2_1_1Module_a7f2cb22a956bb745353461378e3e83e4}{Module\+::init\+Params}} and \mbox{\hyperlink{classnlib2_1_1Module_acccd99465fa5b7b7add56006eecbab9d}{Module\+::setup\+Network}}, that each module shall override. The initialization of the modules is done in the same order they have been loaded.
\end{DoxyItemize}

After initialization, sources can be triggered by calling \mbox{\hyperlink{classnlib2_1_1Modflow_ac6cc3a2e1c7bc9bd974a2f5555e5bcf4}{sources()}} -\/$>$ \mbox{\hyperlink{classnlib2_1_1Sources_a45c2bc6b9ae6006ad4e264f2b7dedff0}{Sources\+::call\+Source}}, which will emit signals on regular channels as defined by Sources\+::declare\+Source\+Channels. Modules connected to such channels will receive a function call on its associated slot, which can in turn emit other signals on other channels, which can then be connected to other modules or to sinks. Differently from regular channels, sink channels are connected to an external callback that acts as exit point of \mbox{\hyperlink{classnlib2_1_1Modflow}{Modflow}}. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classnlib2_1_1Modflow_add865d3950356993cea2d69c790293ca}\label{classnlib2_1_1Modflow_add865d3950356993cea2d69c790293ca}} 
\index{nlib2::Modflow@{nlib2::Modflow}!createChannel@{createChannel}}
\index{createChannel@{createChannel}!nlib2::Modflow@{nlib2::Modflow}}
\doxysubsubsection{\texorpdfstring{createChannel()}{createChannel()}}
{\footnotesize\ttfamily template$<$typename ... Channel\+Ts$>$ \\
\mbox{\hyperlink{classnlib2_1_1Channel}{Channel}} nlib2\+::\+Modflow\+::create\+Channel (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{name,  }\item[{const \mbox{\hyperlink{classnlib2_1_1Module}{Module}} $\ast$}]{owner,  }\item[{bool}]{is\+Sink = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Declare a new channel of types {\ttfamily }...Channel\+Ts. The channel is owned by module {\ttfamily owner}, that is the only module that can emit events on this channel. 

\begin{DoxyReturn}{Returns}
A new \mbox{\hyperlink{classnlib2_1_1Channel}{Channel}} object with the created channel information 
\end{DoxyReturn}
\mbox{\Hypertarget{classnlib2_1_1Modflow_afcdf38dcbcf1db61f8d1ace93064c7db}\label{classnlib2_1_1Modflow_afcdf38dcbcf1db61f8d1ace93064c7db}} 
\index{nlib2::Modflow@{nlib2::Modflow}!createConnection@{createConnection}}
\index{createConnection@{createConnection}!nlib2::Modflow@{nlib2::Modflow}}
\doxysubsubsection{\texorpdfstring{createConnection()}{createConnection()}}
{\footnotesize\ttfamily template$<$typename ReturnT , typename ... Channel\+Ts$>$ \\
void nlib2\+::\+Modflow\+::create\+Connection (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classnlib2_1_1Channel}{Channel}} \&}]{channel,  }\item[{const Slot$<$ ReturnT, Channel\+Ts... $>$ \&}]{slot,  }\item[{const std\+::string \&}]{name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Create a connection named {\ttfamily name} from {\ttfamily channel} to a {\ttfamily slot} function. 

\begin{DoxyNote}{Note}
Do not call this method directly. Use \mbox{\hyperlink{classnlib2_1_1Module_ac11760280acec17fa03dbf40c4e1e215}{Module\+::request\+Connection}} or \mbox{\hyperlink{classnlib2_1_1Sinks_a03520b4274f119870dc971dbdd26256b}{Sinks\+::declare\+Sink}} 
\end{DoxyNote}
\mbox{\Hypertarget{classnlib2_1_1Modflow_a937c5c08735a23fa5fcf92178f960fe2}\label{classnlib2_1_1Modflow_a937c5c08735a23fa5fcf92178f960fe2}} 
\index{nlib2::Modflow@{nlib2::Modflow}!emit@{emit}}
\index{emit@{emit}!nlib2::Modflow@{nlib2::Modflow}}
\doxysubsubsection{\texorpdfstring{emit()}{emit()}}
{\footnotesize\ttfamily template$<$typename ReturnT , typename ... Channel\+Ts$>$ \\
std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+same\+\_\+v$<$ ReturnT, void $>$, ReturnT $>$ nlib2\+::\+Modflow\+::emit (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classnlib2_1_1Channel}{Channel}} \&}]{channel,  }\item[{const \mbox{\hyperlink{classnlib2_1_1Module}{Module}} $\ast$}]{caller,  }\item[{Channel\+Ts \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Emit a signal on {\ttfamily channel}. This will call the slot methods associated to the channel of each module, supplying {\ttfamily }...args. 

\begin{DoxyReturn}{Returns}
If ReturnT is not void, forwards the return value of {\ttfamily slot}. In this case only one slot can be connected per channel 
\end{DoxyReturn}
\mbox{\Hypertarget{classnlib2_1_1Modflow_a7454ed4e6961c6db8d5adf2128250b73}\label{classnlib2_1_1Modflow_a7454ed4e6961c6db8d5adf2128250b73}} 
\index{nlib2::Modflow@{nlib2::Modflow}!loadModule@{loadModule}}
\index{loadModule@{loadModule}!nlib2::Modflow@{nlib2::Modflow}}
\doxysubsubsection{\texorpdfstring{loadModule()}{loadModule()}}
{\footnotesize\ttfamily template$<$class Derived\+Module , typename ... Args$>$ \\
Derived\+Module\+::\+Shared\+Ptr nlib2\+::\+Modflow\+::load\+Module (\begin{DoxyParamCaption}\item[{Args \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Construct a dynamically allocated object of type {\ttfamily Derived\+Module}, as shared pointer, and stores into \mbox{\hyperlink{classnlib2_1_1Modflow}{Modflow}}\textquotesingle{}s modules list. 

\begin{DoxyReturn}{Returns}
Pointer to created module 
\end{DoxyReturn}
\mbox{\Hypertarget{classnlib2_1_1Modflow_a8a04230250ef2707a601efe38be834d7}\label{classnlib2_1_1Modflow_a8a04230250ef2707a601efe38be834d7}} 
\index{nlib2::Modflow@{nlib2::Modflow}!resolveChannel@{resolveChannel}}
\index{resolveChannel@{resolveChannel}!nlib2::Modflow@{nlib2::Modflow}}
\doxysubsubsection{\texorpdfstring{resolveChannel()}{resolveChannel()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classnlib2_1_1Channel}{Channel}} nlib2\+::\+Modflow\+::resolve\+Channel (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}



Get a \mbox{\hyperlink{classnlib2_1_1Channel}{Channel}} object given its name. 

\begin{DoxyParagraph}{Complexity Logarithmic in the number of channels}

\end{DoxyParagraph}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/nlib2/\mbox{\hyperlink{nl__modflow_8h}{nl\+\_\+modflow.\+h}}\item 
include/nlib2/nl\+\_\+modflow\+\_\+impl.\+hpp\end{DoxyCompactItemize}
