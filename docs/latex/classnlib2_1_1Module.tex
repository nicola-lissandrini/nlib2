\hypertarget{classnlib2_1_1Module}{}\doxysection{nlib2\+::Module Class Reference}
\label{classnlib2_1_1Module}\index{nlib2::Module@{nlib2::Module}}


This is the core node of a \mbox{\hyperlink{classnlib2_1_1Modflow}{Modflow}} graph. Inherit this class to define the main computation units to happen in this module. Each module can define new Channels to which it can emit output events after computation is done, and request channels to connect to when data is transmitted on such channels.  




{\ttfamily \#include $<$nl\+\_\+modflow.\+h$>$}



Inheritance diagram for nlib2\+::Module\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=256pt]{classnlib2_1_1Module__inherit__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classnlib2_1_1Module_a20427de9dd681179d92a93602f07d33e}\label{classnlib2_1_1Module_a20427de9dd681179d92a93602f07d33e}} 
const std\+::string \& \mbox{\hyperlink{classnlib2_1_1Module_a20427de9dd681179d92a93602f07d33e}{name}} () const
\begin{DoxyCompactList}\small\item\em Get module name. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlib2_1_1Module_a17ed883471261b266118cddd0c2cbb77}\label{classnlib2_1_1Module_a17ed883471261b266118cddd0c2cbb77}} 
Event\+::\+Shared\+Ptr \mbox{\hyperlink{classnlib2_1_1Module_a17ed883471261b266118cddd0c2cbb77}{last\+Event}} () const
\begin{DoxyCompactList}\small\item\em For internal use. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classnlib2_1_1Module_a7f2cb22a956bb745353461378e3e83e4}{init\+Params}} (const Nl\+Params\+::\+Shared\+Ptr \&nl\+Params)
\begin{DoxyCompactList}\small\item\em Override this method to (optionally) initialize the parameters Parameters are supplied during the execution of \mbox{\hyperlink{classnlib2_1_1Modflow_a6fb940191b88b5127e2e48ea1ed1033e}{Modflow\+::finalize}}. The nl\+Params object is already scoped with the parameters accessed by e.\+g. \char`\"{}module\+X\char`\"{} must be defined as module\+X.\+params. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlib2_1_1Module_acccd99465fa5b7b7add56006eecbab9d}\label{classnlib2_1_1Module_acccd99465fa5b7b7add56006eecbab9d}} 
virtual void \mbox{\hyperlink{classnlib2_1_1Module_acccd99465fa5b7b7add56006eecbab9d}{setup\+Network}} ()=0
\begin{DoxyCompactList}\small\item\em Implement this method to handle the connections. Create channels (see \mbox{\hyperlink{classnlib2_1_1Module_a0e5a70b31f0f283e853df656b5318ffb}{Module\+::create\+Channel}}) for outbound connections and request connections from inbound channels (see \mbox{\hyperlink{classnlib2_1_1Module_ac11760280acec17fa03dbf40c4e1e215}{Module\+::request\+Connection}}) \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlib2_1_1Module_a970f99697e3962d5f0b118a645eb4eda}\label{classnlib2_1_1Module_a970f99697e3962d5f0b118a645eb4eda}} 
bool \mbox{\hyperlink{classnlib2_1_1Module_a970f99697e3962d5f0b118a645eb4eda}{is\+Enabled}} () const
\begin{DoxyCompactList}\small\item\em Retruns true when all \char`\"{}enabling channels\char`\"{} have been triggered at least once (see \mbox{\hyperlink{classnlib2_1_1Module_a5f850dfc1c32b9953a0590e2307d6a08}{request\+Enabling\+Channel}}) \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classnlib2_1_1Module_a20254928ec78e1acd3ab91e351a29181}{on\+Param\+Change}} (const std\+::string \&\mbox{\hyperlink{classnlib2_1_1Module_a20427de9dd681179d92a93602f07d33e}{name}}, const Nl\+Params\+::\+Shared\+Ptr \&nl\+Params)
\begin{DoxyCompactList}\small\item\em Should only be called by the \mbox{\hyperlink{classnlib2_1_1Modflow}{Modflow}} object. If \+\_\+automatic\+Param\+Update is true, it re-\/execute init\+Params, and every parameter of the module is re-\/read. Otherwise, it calls your implementation of \mbox{\hyperlink{classnlib2_1_1Module_a9c0900ae011db09d19dd15779e67c6ed}{Module\+::update\+Param}}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classnlib2_1_1Module_ae9596ea9cfaf51d96550d48ce3ab1b75}\label{classnlib2_1_1Module_ae9596ea9cfaf51d96550d48ce3ab1b75}} 
\mbox{\hyperlink{classnlib2_1_1Module_ae9596ea9cfaf51d96550d48ce3ab1b75}{Module}} (const std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classnlib2_1_1Modflow}{Modflow}} $>$ \&modflow, const std\+::string \&\mbox{\hyperlink{classnlib2_1_1Module_a20427de9dd681179d92a93602f07d33e}{name}}, bool automatic\+Param\+Update=true)
\begin{DoxyCompactList}\small\item\em The module can only be created via \mbox{\hyperlink{classnlib2_1_1Modflow_a7454ed4e6961c6db8d5adf2128250b73}{Modflow\+::load\+Module}}, which handles its allocation as shared pointer. For each module, the constructor should have a \mbox{\hyperlink{classnlib2_1_1Modflow}{Modflow}} shared pointer as first argument, and then the optional other argumetns, and forward the pointer to the parent\textquotesingle{}s constructor. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{classnlib2_1_1Module_a9c0900ae011db09d19dd15779e67c6ed}{update\+Param}} (const std\+::string \&\mbox{\hyperlink{classnlib2_1_1Module_a20427de9dd681179d92a93602f07d33e}{name}}, const Nl\+Params\+::\+Shared\+Ptr \&nl\+Params)
\begin{DoxyCompactList}\small\item\em This function is called after on\+Param\+Change when \+\_\+automatic\+Param\+Update is false. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename ... Channel\+Ts, typename Derived\+Module , typename ReturnT $>$ }\\std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+base\+\_\+of\+\_\+v$<$ \mbox{\hyperlink{classnlib2_1_1Module}{Module}}, Derived\+Module $>$ $>$ \mbox{\hyperlink{classnlib2_1_1Module_ac11760280acec17fa03dbf40c4e1e215}{request\+Connection}} (const std\+::string \&channel\+Name, ReturnT(Derived\+Module\+::$\ast$slot)(Channel\+Ts ...))
\begin{DoxyCompactList}\small\item\em Bind signals emitted on a given channel name to a member function {\ttfamily slot} of the derived module The channel types are automatically deduced from the slot arguments. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlib2_1_1Module_a5f850dfc1c32b9953a0590e2307d6a08}\label{classnlib2_1_1Module_a5f850dfc1c32b9953a0590e2307d6a08}} 
void \mbox{\hyperlink{classnlib2_1_1Module_a5f850dfc1c32b9953a0590e2307d6a08}{request\+Enabling\+Channel}} (const std\+::string \&channel\+Name)
\begin{DoxyCompactList}\small\item\em Request a channel to be enabling of the module. Until all enabling channels have been triggered at least once, all other inbound connections are disabled. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlib2_1_1Module_aec788db045ee8b3b6c46e95f9bff4ed6}\label{classnlib2_1_1Module_aec788db045ee8b3b6c46e95f9bff4ed6}} 
void {\bfseries request\+Enabling\+Channel} (const \mbox{\hyperlink{classnlib2_1_1Channel}{Channel}} \&channel\+Name)
\item 
{\footnotesize template$<$typename ... Channel\+Ts$>$ }\\\mbox{\hyperlink{classnlib2_1_1Channel}{Channel}} \mbox{\hyperlink{classnlib2_1_1Module_a0e5a70b31f0f283e853df656b5318ffb}{create\+Channel}} (const std\+::string \&\mbox{\hyperlink{classnlib2_1_1Module_a20427de9dd681179d92a93602f07d33e}{name}})
\begin{DoxyCompactList}\small\item\em Create a standard channel of types {\ttfamily Channel\+Ts} named {\ttfamily name}, owned by this module (. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlib2_1_1Module_a5e3326ea48cf3830b2e2d7fdf65ba8b3}\label{classnlib2_1_1Module_a5e3326ea48cf3830b2e2d7fdf65ba8b3}} 
{\footnotesize template$<$typename ... Channel\+Ts$>$ }\\\mbox{\hyperlink{classnlib2_1_1Channel}{Channel}} \mbox{\hyperlink{classnlib2_1_1Module_a5e3326ea48cf3830b2e2d7fdf65ba8b3}{require\+Sink}} (const std\+::string \&sink\+Name)
\begin{DoxyCompactList}\small\item\em Ensures the parent object has declared a sink named {\ttfamily sink\+Name} with types {\ttfamily Channel\+Ts}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlib2_1_1Module_ab5496393925fe31dff541b12acc8bdac}\label{classnlib2_1_1Module_ab5496393925fe31dff541b12acc8bdac}} 
{\footnotesize template$<$typename ... Channel\+Ts$>$ }\\void \mbox{\hyperlink{classnlib2_1_1Module_ab5496393925fe31dff541b12acc8bdac}{emit}} (const \mbox{\hyperlink{classnlib2_1_1Channel}{Channel}} \&channel, Channel\+Ts \&\&...value)
\begin{DoxyCompactList}\small\item\em Emit a signal on {\ttfamily channel}. All slot of every module connected to the specified channel in will be called with the data {\ttfamily value}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename ... Channel\+Ts$>$ }\\void \mbox{\hyperlink{classnlib2_1_1Module_aafa715c9bae509cad8b756cdd03ccfcf}{emit}} (const std\+::string \&channel, Channel\+Ts \&\&...value)
\begin{DoxyCompactList}\small\item\em As. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename ReturnT , typename ... Channel\+Ts$>$ }\\ReturnT \mbox{\hyperlink{classnlib2_1_1Module_a8fcde72c623adde3389fef11c1110974}{call\+Service}} (const \mbox{\hyperlink{classnlib2_1_1Channel}{Channel}} \&channel, Channel\+Ts \&\&...value)
\begin{DoxyCompactList}\small\item\em Emit a signal on a {\ttfamily channel} that has non-\/void return value. The principle is the same as. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlib2_1_1Module_aa9aa943742b266541326cf4ff897f444}\label{classnlib2_1_1Module_aa9aa943742b266541326cf4ff897f444}} 
{\footnotesize template$<$typename ReturnT , typename ... Channel\+Ts$>$ }\\ReturnT {\bfseries call\+Service} (const std\+::string \&channel, Channel\+Ts \&\&...value)
\item 
const \mbox{\hyperlink{classnlib2_1_1ResourceManager}{Resource\+Manager}} \& \mbox{\hyperlink{classnlib2_1_1Module_a62815fd3610c566e2164d76ddf500c5f}{resources}} () const
\begin{DoxyCompactList}\small\item\em Handle to centralized \mbox{\hyperlink{classnlib2_1_1Modflow}{Modflow}}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classnlib2_1_1Module_a683acecccc38e4c0d4128439a7332aa9}\label{classnlib2_1_1Module_a683acecccc38e4c0d4128439a7332aa9}} 
\mbox{\hyperlink{classnlib2_1_1ResourceManager}{Resource\+Manager}} \& {\bfseries resources} ()
\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classnlib2_1_1Module_a6f02c43f42bda13af006df168a1b8848}\label{classnlib2_1_1Module_a6f02c43f42bda13af006df168a1b8848}} 
std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classnlib2_1_1Modflow}{Modflow}} $>$ {\bfseries \+\_\+modflow}
\item 
\mbox{\Hypertarget{classnlib2_1_1Module_a21e0d8a4854b966d4e97f1d5104e0962}\label{classnlib2_1_1Module_a21e0d8a4854b966d4e97f1d5104e0962}} 
Event\+::\+Shared\+Ptr {\bfseries \+\_\+last\+Event}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
This is the core node of a \mbox{\hyperlink{classnlib2_1_1Modflow}{Modflow}} graph. Inherit this class to define the main computation units to happen in this module. Each module can define new Channels to which it can emit output events after computation is done, and request channels to connect to when data is transmitted on such channels. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classnlib2_1_1Module_a8fcde72c623adde3389fef11c1110974}\label{classnlib2_1_1Module_a8fcde72c623adde3389fef11c1110974}} 
\index{nlib2::Module@{nlib2::Module}!callService@{callService}}
\index{callService@{callService}!nlib2::Module@{nlib2::Module}}
\doxysubsubsection{\texorpdfstring{callService()}{callService()}}
{\footnotesize\ttfamily template$<$typename ReturnT , typename ... Channel\+Ts$>$ \\
ReturnT nlib2\+::\+Module\+::call\+Service (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classnlib2_1_1Channel}{Channel}} \&}]{channel,  }\item[{Channel\+Ts \&\&...}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Emit a signal on a {\ttfamily channel} that has non-\/void return value. The principle is the same as. 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classnlib2_1_1Module_ab5496393925fe31dff541b12acc8bdac}{Module\+::emit}}, but only one slot can be connected (

\mbox{\hyperlink{classnlib2_1_1Module_ac11760280acec17fa03dbf40c4e1e215}{Module\+::request\+Connection}} will fail when trying to connect to a channel to which another slot is already connected) 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classnlib2_1_1Module_a0e5a70b31f0f283e853df656b5318ffb}\label{classnlib2_1_1Module_a0e5a70b31f0f283e853df656b5318ffb}} 
\index{nlib2::Module@{nlib2::Module}!createChannel@{createChannel}}
\index{createChannel@{createChannel}!nlib2::Module@{nlib2::Module}}
\doxysubsubsection{\texorpdfstring{createChannel()}{createChannel()}}
{\footnotesize\ttfamily template$<$typename ... Channel\+Ts$>$ \\
\mbox{\hyperlink{classnlib2_1_1Channel}{Channel}} nlib2\+::\+Module\+::create\+Channel (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Create a standard channel of types {\ttfamily Channel\+Ts} named {\ttfamily name}, owned by this module (. 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classnlib2_1_1Modflow_add865d3950356993cea2d69c790293ca}{Modflow\+::create\+Channel}} for details) 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classnlib2_1_1Module_aafa715c9bae509cad8b756cdd03ccfcf}\label{classnlib2_1_1Module_aafa715c9bae509cad8b756cdd03ccfcf}} 
\index{nlib2::Module@{nlib2::Module}!emit@{emit}}
\index{emit@{emit}!nlib2::Module@{nlib2::Module}}
\doxysubsubsection{\texorpdfstring{emit()}{emit()}}
{\footnotesize\ttfamily template$<$typename ... Channel\+Ts$>$ \\
void nlib2\+::\+Module\+::emit (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{channel,  }\item[{Channel\+Ts \&\&...}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



As. 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classnlib2_1_1Module_ab5496393925fe31dff541b12acc8bdac}{Module\+::emit}} (const \mbox{\hyperlink{classnlib2_1_1Channel}{Channel}} \&channel,...) but it resolves the channel \mbox{\hyperlink{classnlib2_1_1Module_a20427de9dd681179d92a93602f07d33e}{name}} (small overhead for \mbox{\hyperlink{classnlib2_1_1Module_a20427de9dd681179d92a93602f07d33e}{name}} resolution) 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classnlib2_1_1Module_a7f2cb22a956bb745353461378e3e83e4}\label{classnlib2_1_1Module_a7f2cb22a956bb745353461378e3e83e4}} 
\index{nlib2::Module@{nlib2::Module}!initParams@{initParams}}
\index{initParams@{initParams}!nlib2::Module@{nlib2::Module}}
\doxysubsubsection{\texorpdfstring{initParams()}{initParams()}}
{\footnotesize\ttfamily virtual void nlib2\+::\+Module\+::init\+Params (\begin{DoxyParamCaption}\item[{const Nl\+Params\+::\+Shared\+Ptr \&}]{nl\+Params }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Override this method to (optionally) initialize the parameters Parameters are supplied during the execution of \mbox{\hyperlink{classnlib2_1_1Modflow_a6fb940191b88b5127e2e48ea1ed1033e}{Modflow\+::finalize}}. The nl\+Params object is already scoped with the parameters accessed by e.\+g. \char`\"{}module\+X\char`\"{} must be defined as module\+X.\+params. 


\begin{DoxyParams}{Parameters}
{\em nl\+Params} & Obtained as nl\+Params-\/$>$derived(module-\/$>$\mbox{\hyperlink{classnlib2_1_1Module_a20427de9dd681179d92a93602f07d33e}{name()}}) \\
\hline
\end{DoxyParams}


Reimplemented in \mbox{\hyperlink{classnlib2_1_1Sinks_a48be1783056a77c2752e025693182539}{nlib2\+::\+Sinks}}, and \mbox{\hyperlink{classnlib2_1_1Sources_aca0227deae0692e1736038936ccdf7cc}{nlib2\+::\+Sources}}.

\mbox{\Hypertarget{classnlib2_1_1Module_a20254928ec78e1acd3ab91e351a29181}\label{classnlib2_1_1Module_a20254928ec78e1acd3ab91e351a29181}} 
\index{nlib2::Module@{nlib2::Module}!onParamChange@{onParamChange}}
\index{onParamChange@{onParamChange}!nlib2::Module@{nlib2::Module}}
\doxysubsubsection{\texorpdfstring{onParamChange()}{onParamChange()}}
{\footnotesize\ttfamily void nlib2\+::\+Module\+::on\+Param\+Change (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{name,  }\item[{const Nl\+Params\+::\+Shared\+Ptr \&}]{nl\+Params }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Should only be called by the \mbox{\hyperlink{classnlib2_1_1Modflow}{Modflow}} object. If \+\_\+automatic\+Param\+Update is true, it re-\/execute init\+Params, and every parameter of the module is re-\/read. Otherwise, it calls your implementation of \mbox{\hyperlink{classnlib2_1_1Module_a9c0900ae011db09d19dd15779e67c6ed}{Module\+::update\+Param}}. 


\begin{DoxyParams}{Parameters}
{\em name} & Scoped parameter name \\
\hline
{\em nl\+Params} & Nl\+Param object pointer \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classnlib2_1_1Module_ac11760280acec17fa03dbf40c4e1e215}\label{classnlib2_1_1Module_ac11760280acec17fa03dbf40c4e1e215}} 
\index{nlib2::Module@{nlib2::Module}!requestConnection@{requestConnection}}
\index{requestConnection@{requestConnection}!nlib2::Module@{nlib2::Module}}
\doxysubsubsection{\texorpdfstring{requestConnection()}{requestConnection()}}
{\footnotesize\ttfamily template$<$typename ... Channel\+Ts, typename Derived\+Module , typename ReturnT $>$ \\
std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+base\+\_\+of\+\_\+v$<$ \mbox{\hyperlink{classnlib2_1_1Module}{Module}}, Derived\+Module $>$ $>$ nlib2\+::\+Module\+::request\+Connection (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{channel\+Name,  }\item[{ReturnT(Derived\+Module\+::$\ast$)(Channel\+Ts ...)}]{slot }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Bind signals emitted on a given channel name to a member function {\ttfamily slot} of the derived module The channel types are automatically deduced from the slot arguments. 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classnlib2_1_1Modflow_afcdf38dcbcf1db61f8d1ace93064c7db}{Modflow\+::create\+Connection}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classnlib2_1_1Module_a62815fd3610c566e2164d76ddf500c5f}\label{classnlib2_1_1Module_a62815fd3610c566e2164d76ddf500c5f}} 
\index{nlib2::Module@{nlib2::Module}!resources@{resources}}
\index{resources@{resources}!nlib2::Module@{nlib2::Module}}
\doxysubsubsection{\texorpdfstring{resources()}{resources()}}
{\footnotesize\ttfamily const \mbox{\hyperlink{classnlib2_1_1ResourceManager}{Resource\+Manager}} \& nlib2\+::\+Module\+::resources (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}



Handle to centralized \mbox{\hyperlink{classnlib2_1_1Modflow}{Modflow}}. 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{classnlib2_1_1ResourceManager}{Resource\+Manager}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{classnlib2_1_1Module_a9c0900ae011db09d19dd15779e67c6ed}\label{classnlib2_1_1Module_a9c0900ae011db09d19dd15779e67c6ed}} 
\index{nlib2::Module@{nlib2::Module}!updateParam@{updateParam}}
\index{updateParam@{updateParam}!nlib2::Module@{nlib2::Module}}
\doxysubsubsection{\texorpdfstring{updateParam()}{updateParam()}}
{\footnotesize\ttfamily virtual void nlib2\+::\+Module\+::update\+Param (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{name,  }\item[{const Nl\+Params\+::\+Shared\+Ptr \&}]{nl\+Params }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



This function is called after on\+Param\+Change when \+\_\+automatic\+Param\+Update is false. 


\begin{DoxyParams}{Parameters}
{\em name} & \\
\hline
{\em nl\+Params} & \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/nlib2/\mbox{\hyperlink{nl__modflow_8h}{nl\+\_\+modflow.\+h}}\item 
include/nlib2/nl\+\_\+modflow\+\_\+impl.\+hpp\end{DoxyCompactItemize}
